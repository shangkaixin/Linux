### 内核驱动模块
#### 1. 内核驱动模块三要素
1. 头文件
```c
#include <linux/init.h>
#include <linux/module.h>
```

2. 注册驱动注册函数和驱动卸载函数
```c
module_init(module_init);
module_exit(module_exit);
```

3. 声明使用的协议
```c
MODULE_LICENSE("GPL");
```

#### 2. 完整示例
```c
#include <linux/init.h>
#include <linux/module.h>

static int __init myModuleInit(void)
{
    //TODO:这里写驱动注册
}

static void __init myModuleExit(void)
{
    //TODO:这里写驱动卸载
}

module_init(myModuleInit);
module_exit(myModuleExit);
MODULE_LINCENSE("GPL");
```

#### 3. 传参
```c
module_param(name, type, perm);
//参数1：表示参数的命名成
//参数2：表示参数的类型
//参数3：表示参数的文件权限，0644
```

#### 4. 符号表导出
```c
EXPORT_SYMBOL(function_symbol);
```

### 字符串驱动
#### 1. 字符串驱动注册函数
```c
#include <linux/fs.h>

int register_chrdev(unsigned int major, const char* name, const struct file_operaions* fop);
//参数1：主设备号
//参数2：字符串设备名
//参数3：字符串设备操作函数结构体
void unregister_chrdev(unsinged int major, const char* name);
```

#### 2. 字符串驱动节点声明
```c
#include <linux/device.h>

struct class *class_create(owner, name);
//参数1：THIS_MODULE
//参数2：字符串名称，自定义
//返回值：返回类的指针
struct device *device_crete(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt,...);
//参数1：要加入的类的指针
//参数2：父对象，一般填NULL
//参数3：设备号， dev_t设备号结构体，MKDEV(major, minor)创建设备号
//参数4：私有数据，一般填NULL
//参数5和6：可变参数，字符串，表示设备节点的名字

void device_destory(devcls, MKDEV(major, minor));
void class_destory(device);
```

#### 3. 字符串驱动文件操作
```c
#inlcude <linux/fs.h>

//文件操作原型
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	int (*readdir) (struct file *, void *, filldir_t);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
};

//自定义
const struct file_operations myFops = {
    .open = chrDevOpen,
    .read = chrDevRead,
    .write = chrDevWrite,
    .close = chrDevClose,
}

int charDevOpen (struct inode *, struct file *);
ssize_t chrDevRead (struct file *, char __user *, size_t, loff_t *);
ssize_t chrDevWrite (struct file *, const char __user *, size_t, loff_t *);
int chrDevClose (struct inode *, struct file *);
```

#### 4. 应用层操作字符串驱动设备
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(void)
{
    int fd;
    char *value;
    
    fd = open("/dev/chrname",O_RDWR); //通过设备节点，打开字符串设备
    if(fd < 0)
    {
        perror("open char driver");
        exit(1);
	}
    read(fd, &value, 4); //读取字符串设备值
    write(fd, &value, 4); //写入字符串设备值
    
    close(fd); //关闭字符串设备
    
    return 0;
}
```

#### 5. 应用程序和驱动传递数据
```c
#include <asm/uaccess.h>

int copy_to_user(void __user *to, const void *from, unsigned long n);
//将数据拷贝到用户空间，对用户来说，对应着读数据 char_dev_read()
//参数1：应用驱动中的一个Buffer
//参数2：内核空间到一个Buffer
//参数3：数据大小
//返回值：大于0，出错；等于0，成功
int copy_from_user(void *to, const void __user *from, unsigned long n);
//将数据从用户空间拷贝出来，对用户来说，相当于写数据 char_dev_write()
```
```c
ssize_t char_drv_read(struct file *filp, char __user *buf, size_t count, loff_t *fops)
{
    int ret;
    printk("------%s------\n",__FUNCTION__);
    
    ret = copy_to_user(buf, &kernel_value, count);
    if(ret > 0){
        printk("Copy to user error\n");
        return -EFAULT;
    }
    return 0;
}

ssize_t char_drv_write(struct file *filp, char __user *buf, size_t count, loff_t *fops)
{
    int ret;
    printk("------%s------\n",__FUNCTION__);
    
    ret = copy_from_user(buf, &kernel_value, count);
    if(ret > 0){
        printk("Copy to user error\n");
        return -EFAULT;
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
    int fd;
    char *value;
    
    fd = open("/dev/chrname",O_RDWR); //通过设备节点，打开字符串设备
    if(fd < 0)
    {
        perror("open char driver");
        exit(1);
	}
    read(fd, &value, 4); //读取字符串设备值
    printf("__USER__: %s\n",value);
    write(fd, &value, 4); //写入字符串设备值
    
    close(fd); //关闭字符串设备
    
    return 0;
}
```

#### 6. 地址映射
```c
void *ioremap(cookie, size);
//参数1：物理地址
//参数2：长度
//返回值：虚拟地址

void iounmap(void __iomem *addr);
//参数1：映射之后的地址
```

### 实例：LED驱动开发
#### 1. 原理图分析
#### 2. 手册分析
#### 3. 驱动代码编写
```c
#inlcude <linux/init.h>
#include <linux/module.h>
#include <linux/type.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <asm/uaccess.h>

#define GPIOCON 0x11400C40
#define GPIODAT 0x11400C44

#define MAJOR 300
#define DEVNAME "LED_Device"

static int __init LED_Init(void){
    register_chrdev();
    class_create();
    device_create();
    ioremap();
}

static int __exit LED_Exit(void){
    device_uncreate();
    class_uncreate();
    unregister_chrdev();
    iounmap();
}

int LED_Open(){
    readl();
    writel();
}

int LED_Close(){
    
}

ssize_t LED_Read(){
    copy_to_user();
}

ssize_t LED_Write(){
    copy_from_user();
}

const struct file_operations = {
    .open = LED_Open,
    .release = LED_Close,
    .read = LED_Read,
    .write = LED_Write,
}

module_init(LED_Init);
module_exit(LED_Exit);
MODULE_LICNESE("GPL");
```

### 中断编程
#### 1. 中断号和中断申请
1. 中断号和硬件有关，定义在芯片手册上。首先需要查看芯片手册，确定相应的中断号，然后将中断号相关的设备节点编译到设备描述文件里。在arch/arm/boot/dts/文件夹下，打开dts树文件，

2. 在驱动中获取终端号，并申请中断
```c
struct device_node* of_find_node_by_path("node path"); //获取设备树中的节点
int irq_of_parse_and_map(struct device_node *dev, int index); //通过节点获取中断号

int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, chonst char *name, void *dev);
//参数1：设备对应的中断号
//参数2：中断处理函数
//参数3：触发方式
//参数4：中断描述，自定义，在/proc/interrupts查看
//参数5：传递给参数2
//返回值：成功为0；错误为非0

void free_irq(unsigned int irq, void *dev_id);
//参数1：中断号
//参数2：与request_irq中的参数5保持一致
```
3. 实现字符串设备驱动中断(伪代码)
```c
//设计一个全局设备对象
struct key_desc{
  unsigned int dev_major;
  struct class *cls;
  struct device *dev;
  int irqno;
  unsigned int* data_reg;
};

struct key_dev *key_dev;
struct key_event *event;

int key_drv_open(struct inode* inode, struct file *file){
    
}

int key_drv_close(struct inode* inode, struct file* file){
    
}

ssize_t key_drv_read(struct file* file, char __user* buf, size_t loff_t* loft){
    copy_to_user(buf, &value, count);
}

ssize_t key_drv_write(struct file* file, const char __user* buf, size_t loff_t* loft){
    
}

const strcut file_operations fops = {
    .open = key_drv_open,
    .release = key_drv_close,
    .read = key_drv_read,
    .write = key_drv_write,
};
struct device_node *devnode;

void key_irq_handler(int irqno, void* devid){
    int value = readl(key_dev->data_reg) & (1<<2);
}

static int __init Key_drv_init(void){
    int ret;
    //1. 设定一个全局的设备对象
    key_dev = kzalloc(sizeof(struct key_desc), GFP_KERNEL);
    //2. 申请设备号
    key_dev->dev_major = register_chrdev(0, "key_drv",fops);
    //3. 创建设备节点文件
    key_dev->cls = class_create(THIS_MODULE, "key_cls");
    key_dev->dev = device_create(key_dev->cls, NULL, MKDEV(key_dev->dev_major,0), NULL, "key0");
    //4. 硬件初始化，申请中断
    devnode = of_find_node_by_path("/dev/key0");
    key_dev->irqno = irq_of_parse_and_map(devnode, int index);
    ret = request_irq(key_dev->irqno, key_irq_handler,IRQF_TRIGGER_FALLING, "key3_exit10", NULL);
    //5. 映射寄存器地址
    key_dev->data_reg = ioremap();
}

static int __exit Key_drv_exit(void){
    free_irq(key_dev->irqno, NULL);
    device_destory(key_dev->cls, MKDEV(key_dev->dev_major, 0));
    class_destory(key_dev->cls);
    unregister_chrdev(key_dev->dev_major, "key_drv");
    kfree(key_dev);
}

module_init(Key_drv_init);
module_exit(Key_drv_exit);
MODULE_LICNESE("GPL");
```

#### 2. IO模型
1. 在之前的驱动中，应用程序while(1)循环在一直和驱动交流，导致驱动占用CPU 100%，这样效率很低。
2. 四种模型：阻塞模型，非阻塞模型，多路复用IO，异步信号
3. 阻塞模型，等同于休眠。当进程在读取外部设备的资源（数据），资源没有准备好，进程就会休眠，Linux应用中，大部分的函数接口都是阻塞：scanf(); read(); write(); accept()
```c
add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); //将当前进程加入到等待队列头中
set_current_state(TASK_INTERRUPTIBLE); //将当前进程状态设置成可中断状态
schedule(void); //让出调度-休眠

init_waitqueue_head(wait_queue_head_t *q); //初始化等待队列头
wait_event_interruptible(wait_queue_head_t* wq, condition); //调用了以上三个函数，实现阻塞
//参数1：等待队列头
//参数2：条件，如果为假，就会等待，如果为真，不会等待
wake_up_interruptible(wait_queue_head_t* wq); //在有合适的数据的时候，会将进程唤醒
```

4. 多路复用：select，poll。内核对文件描述符fd监控，当有fd读、写、出错时，执行程序
+ select
+ poll
```c
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
struct pollfd{
    int fd; /*file descriptor*/
    short events; /*requested events*/
    short revents; /*returned events*/
}
//参数2：被监控的文件描述符的个数
//参数3：超时，正数为监控的ms，负数为无限制监控
//返回值：>0数组中fds准备好读、写或出错的fd的数量，=0没有fd准备好，-1函数调用失败

/*应用层使用*/
struct pollfd pfd[2]; //声明两个poll监控
pfd[0].fd = fd1; //监控fd1
pfd[0].events = POLLIN; //监控标准输入

while(1){
   ret = poll(pfd, 2, -1);
   if(ret > 0){
      if(fd[0].revnets & POLLIN){
        //获取数据
    }
   }else{
    
   } 
}

/*驱动层实现poll接口*/
const struct file_operations = {
    .poll = my_poll,
};

unsigned int my_poll(struct file* file, struct poll_table_struct *pts){
    //返回一个mask值
    unsigned int mask = 0;
    //调用poll_wait，将当前的等待队列注册系统中
    pollwait(file,&key_dev->wq_head,pts)
    //1. 当没有数据的时候返回一个0
    if(!key_dev->key_state)
        mask = 0;
    //2. 当有数据的时候返回一个POLLIN
    if(key_dev->key_state)
        mask |= POLLIN;
    
    return mask;
}
```

5. 异步信号通知：fasync，当有数据的时候，驱动会发送信号给应用，应用异步读取数据
```c
/*应用程序*/

void catch_signale(int signo){
    if(signo == SIGIO){
        //获取数据
    }
}

int main(void){
    //设置信号处理方法
    signal(SIGIO, catch_signale);
	//将当前进程设置成SIGIO的属主进程
	fcntl(fd, F_SETOWN, getpid());
	//将io模式设置成异步模式
    int flags = fcntl(fd, F_GETFL);
	fcntl(fd, F_SETFL, flags|FASYNC);
}


/*驱动程序*/
const struct file_operations = {
    .fasync = my_fasync,
};

unsigned int my_fasync(int fd, struct file *file, int on){
    //记录信号发送给谁
    return fasync_helper(fd, file, on, &key_dev->fasync);
}

void key_irq_handler(int irqno){
    //发送信号
    kill_fasync(&key_dev->fasync, SIGIO, POLLIN);
}
```


#### 3. 中断下半部
1. 在irq_handler函数中的代码，称为中断上半部
2. 中断下半部：将耗时的操作延后
+ softirq：处理比较快，但是是内核级别的机制，需要修改内核源码，不推荐
+ tasklet：内部实现调用了softirq
```c
struct tasklet_struct{
    struct tasklet_struct *next;
    unsigned long state;
    atomic_t count;
    void (*func)(unsigned long); //下半部的实现方法
    unsigned long data;
}
//初始化
tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);
//在上半部中放入到内核线程中
tasklet_schedule(struct tasklet_struct *t);
//模块卸载后，移除下半部
tasklet_kill(struct tasklet_struct *t);
```
+ workqueue：工作队列
```c
typedef void (*work_func_t)(struct work_struct *work);
struct work_struct{
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
    #ifdef
    struct lockdep_map lockdep_map;
    #endif
};
//初始化
INIT_WORK(struct work_struct *work, work_func_t func);
//在上半部中放入到内核线程中
schedule_work(struct work_struct *work);
```

#### 4. timer定时器

### 平台总线
#### 1. 设备驱动模型
1. 实现入口函数xxx_init()和卸载函数xxx_exit()
2. 申请设备号 register_chrdev()
3. 利用class_create和device_create创建设备节点
4. 硬件部分初始化，io资源映射ioremap，注册中断
5. 构建file_operations结构
6. 实现硬件的操作xxx_open，xxx_read，xxx_write
7. 将与硬件设备有关的代码和与驱动有关的代码分开，挂载在总线上，由总线根据名字匹配。内核Bus总线维护了Device和Driver的链表
8. /sys文件下，维护了class, bus, devices设备

#### 2. 总线创建
<img src="F:\学习笔记\Linux\驱动开发_初级.assets\image-20200331162254437.png" alt="image-20200331162254437" style="zoom:50%;" />
```c
struct bus_type{ //总线对象，描述一个总线，管理device 和 driver，完成匹配
    const char *name; //总线名称
    int (*match)(struct device *dev, struct device_driver *drv); //匹配设备和驱动
}
//注册总线
int bus_register(struct bus_type *bus);
//注销总线
void bus_unregister(struct bus_type *bus);
```
```c
struct bus_type mybus = {
    .name = "mybus",
};

static int __init MyBus_Init(void){
    //构建一个总线,/sys/bus/mybus
    int ret = bus_register(&mybus);
    if(ret < 0){
        printk("error\n");
        return ret;
    }
    return 0;
}

static int __exit MyBus_Exit(void){
    bus_unregister(&mybus);
}

module_init(MyBus_Init);
module_exit(MyBus_Exit);
MODULE_LICENSE("GPL");
EXPORT_SYMBOL(mybus);
```

#### 3. Device对象
设备对象：描述设备信息，包括地址、中断号
```c
struct device{
    struct kobject kobj; //所有对象的父类
    const char *init_name; //在总线中有一个名字用于做匹配，在/sys/bus/mybus/devices
    struct bus_type *bus; //指向加入的总线
    struct device_driver *driver; //指向对应的驱动
    void *plantform_data; //自定义数据，指向任何类型的数据
};
//注册设备
device_register(struct device *dev);
//注销设备
device_unregister(struct device *dev);
```
```c
extern struct bus_type mybus;

struct device mydev = {
    .init_name = "mydev",
    .bus = &mybus,
    .release = &myrelease,
};

static int __init MyDev_Init(void){
    //构建一个总线,/sys/bus/mybus/devices
    int ret = device_register(&mydev);
    if(ret < 0){
        printk("error\n");
        return ret;
    }
    return 0;
}

static int __exit MyDev_Exit(void){
    device_unregister(&mydev);
}

module_init(MyDev_Init);
module_exit(MyDev_Exit);
MODULE_LICENSE("GPL");
EXPORT_SYMBOL(mydev);
```

#### 4. Driver创建
驱动对象：描述设备驱动的方法
```c
struct device_driver{
    const char *name; //驱动名称，/sys/bus/mybus/drivers
    struct bus_type *bus; //所属的总线
    const struct of_device_id *of_match_table; //
    int (*probe)(struct device *dev); //如果deivce和driver匹配，driver要做的事情
    int (*remove)(struct deivce *dev); //device和driver从总线移除之后，driver要做的事情
};
//驱动注册
int driver_register(struct device_driver *drv);
void driver_unregister(struct device_driver *drv);
```
```c
extern struct bus_type mybus;
extern struct device mydev;

int MyDrv_probe(struct device *dev){
    return 0;
}

int MyDrv_remove(struct deivce *dev){
    return 0;
}

struct device_driver mydrv = {
    .name = "mydrv",
    .bus = &mybus,
    .probe = MyDrv_probe,
    .remove = MyDrv_remove,
};

static int __init MyDrv_Init(void){
    //构建一个总线,/sys/bus/mybus/devices
    int ret = driver_register(&mydrv);
    if(ret < 0){
        printk("error\n");
        return ret;
    }
    return 0;
}

static int __exit MyDrv_Exit(void){
    driver_unregister(&mydrv);
}

module_init(MyDrv_Init);
module_exit(MyDrv_Exit);
MODULE_LICENSE("GPL");
EXPORT_SYMBOL(mydrv);
```

#### 5. 总线Bus的匹配
1. 总线完成匹配后，回自动调用driver的probe方法
2. 实现bus中的match方法
```c
int mybus_match(struct device *dev, struct device_driver *drv){
    //如果匹配成功，match方法返回1，失败返回0
    //device和driver中的name应该一致
    if(!strncmp(drv->name, dev->kobj.name, strlen(drv->name))){
        printk("match ok\n");
        return 1;
    }
    return 0;
}

struct bus_type = {
    .match = mybus_match,
}
```

3. 实现驱动probe方法
```c
int MyDrv_probe(struct device *dev){
    printk("---%s---\n",__FUNCTION__);
    return 0;
}
```

4. driver和device合并和分离
```c
//device文件增加device信息
struct mydev_desc{
    char *name;
    int irqno;
    unsigned long addr;
};

struct mydev_desc devinfo = {
    .name = "testdev",
    .irqno = 123,
    .addr = 0x30008000,
};

struct device mydev = {
    .plantform_data = &devinfo,
};

//driver文件可以获取device信息
struct mydev_desc *pdesc;
int mydrv_probe(struct devie *dev){
    pdesc = (struct mydev_desc *)dev->plantform_data;
    unsigned long *paddr = ioremap(pdesc->addr, 8);
}
```

#### 6. 平台总线
1. 为什么会有平台总线？平台总线用于平台升级，硬件平台升级的时候，部分模块的控制方式基本上是一样的，但是模块的地址不一样。平台总线将device(中断/地址)和driver(操作逻辑)分离
2. 平台总线三要素：
+ bus：platform_bus：不需要自己创建，开机的时候自动创建。匹配优先匹配driver中的id_table，直接匹配driver中的名字和device中的名字
+ device：platform_device
+ driver：platform_driver
```c
//平台总线
struct bustype platform_bus_type = {
    .name = "platform",
    .dev_groups = platform_dev_groups,
    .match = platform_match,
    .uevent = platform_match,
    .pm = &platform_dev_pm_ops,
}

//平台设备
struct platform_device{
    const char *name; //用于匹配
    int id; //一般直接给-1
    struct device dev; //继承了device父类
    u32 num_resources; //资源的个数
    struct resource *resource; //资源：包括了一个设备的地址和中断
}
int platform_device_register(struct platform_device *);
void platform_device_unregister(struct platform_device *);

//平台驱动
struct platform_driver{
    int (*probe)(struct platform_device *);
    int (*remove)(struct platform_devie *);
    struct device_driver driver; //继承了driver父类
    const struct platform_device_id *id_table; //如果driver支持多个平台，在列表中写出来
}
int platform_driver_register(struct platform_driver *);
void platform_driver_unregister(struct platform_driver *);
```

3. resource资源
```c
struct resource{
    resource_size_t start; //开始位置
    resource_size_t end; //结束位置
    const char *name; //描述姓名 /sys/bus/platform/deivce
    unsigned long flags; //区分当前资源描述的是中断(IORESOURCE_IRQ)还是内存(IORESOURCE_MEM)
    struct resource *parent, *sibling, *child;
}
```

4. LED实例
```c
/**********创建platform_device对象***********/
struct resource dev_res[] = {
    [0] = {
        .start = 0x11400000,
        .end = 0x11400000 + 24 -1,
        .flags = IORESOURCE_MEM，
    },
};
struct platform_device led_pdev = {
    .name = "led0",
    .id = -1,
    .num_resource = ARRAY_SIZE(dev_res),
    .resource = dev_res,
};

static int __init platform_led_dev_init(void){
    
    return platform_device_register(&led_pdev);;
}

static void __exit platform_led_dev_exit(void){
    platform_device_unregister(&led_pdev);
}

module_init(platform_led_dev_init);
module_exit(platform_led_dev_exit);
MODULE_LICENSE("GPL");

/***********创建platform_driver对象***********/
struct led_dev{
    int major;
    char *name;
    struct class *cls;
    struct device *dev;
    struct resource *res;
    void *reg_addr;
};
struct led_dev led_test;

const struct platform_device_id led_id_table[] = {
    {"led0", 0x1111},
}; //平台id列表

int led_open(struct inode *node, struct file *fp){
    //对寄存器进行配置
    writel((readl(led_test->reg_addr)& ~(0xff<<16))|(0x11<<16),led_test-reg_addr);
    return 0;
}

int led_close(struct inode *node, struct file *fp){
    return 0;
}

ssize_t led_write(struct file *fp, const char __user *buf, size_t count, loff_t *fops){
    int val;
    int ret;
    ret = copy_from_user(&val, buf, count);
    if(ret > 0){
        printk("error\n");
        return -EFAULT;
    }
    if(val){
        writel((readl(led_test->addr+4) | (0x3<<4)), led_test->reg_addr+4);
    }else{
        writel((readl(led_test->addr+4) & ~(0x3<<4)), led_test->reg_addr+4);
    }
    return count;
}

struct file_operations fops = {
    .open = led_open,
    .release = led_close,
    .write = led_write,
};

int led_probe(struct platform_device *pdev){
    printk("----%s----\n",__FUNCTION__);
    led_test = kzalloc(sizeof(struct led_dev), GFP_KERNEL);
    //注册设备号
    led_test->major = register_chrdev(0, "led_drv", &fops);
    //创建设备节点
    led_test->cls = class_create(THIS_MODULE, "LED_cls");
    led_test->dev = device_create(led_test->cls, NULL, MKDEV(led_test->major, 0), NULL, "led0");
    //获取硬件资源
    //platform_get_resource(struct platform_device *pdev, unsigned int type, unsigned int num);
    lest_test->res = platform_get_resource(pedv, IORESOURCE_MEM, 0);
    //初始化硬件
    //ioremap(led_test->res->start, (led_test->res->end - led_test->res->start +1));
    led_test->reg_addr = ioremap(led_test->res->start, resource_size(led_test->res));
    return 0;
}

int led_remove(struct platform_device *pdev){
    device_destory(led_test->cls, MKDEV(led_test->major,0));
    class_destory(led_test->cls);
    unregister_chrdev(led_test->major,"led_drv");
    iounmap(led_test->reg_addr);
    return 0;
}

struct platform_driver pdrv = {
    .probe = led_probe,
    .remove = led_remove,
    .driver = {
        .name = "platform led0", //可以用来做匹配，也可以不用来做匹配
        
    },
    .id_table = led_id_table,
};

static int __init platform_led_drv_init(void){
    
    return platform_driver_register(&led_pdev);;
}

static void __exit platform_led_drv_exit(void){
    platform_driver_unregister(&led_pdev);
}

module_init(platform_led_drv_init);
module_exit(platform_led_drv_exit);
MODULE_LICENSE("GPL");
```
```c
int main(int argc, char *argv[]){
    int fd;
    fd = open("/dev/led0", O_RDWR);
    if(fd < 0){
        perror("open fd");
        return -1;
    }
    
    while(1){
        write(fd,0,4);
        sleep(1);
        write(fd,1,4);
        sleep(1);
    }
}
```

