### 驱动开发初级课程回顾
#### 1. 字符串设备驱动开发
1. 实现入口函数 xxx_init()和卸载函数 xxx_exit()
2. 分配字符串对象  cdev_alloc()
3. 设备对象初始化 cdev_init()
4. 申请设备号 register_chrdev_region()，alloc_chrdev_region()
5. 注册字符串设备驱动 cdev_add()
6. 创建设备节点 class_create(), device_create()
7. 硬件部分初始化
> 1. IO资源映射 ioremap, 内核提供GPIO库函数
> 2. 注册中断
> 3. 初始化等待队列
> 4. 初始化定时器
8. 构建 file_operation结构
9. 实现操作硬件方法 xxx_open(), xxx_read(), xxx_write()......

#### 2. Linux程序框架的概念
1. 内核引入程序框架思想：代码可重用，可维护，可伸缩
2. 通用功能，可重用性好
3. 差异功能，可移植性好
4. 内核框架采用分层
5. 建立设备模型，平台设备驱动
6. 面向对象编程方式

#### 3. 字符串设备高级驱动课程
1. 研究各种子系统（input, i2c, 触摸屏，lcd）
2. 不再是注册字符设备（通用层已经做好）
3. 看手册操作寄存器的比例减少了
4. 大部分的搭框架，研究子系统找到最底层平台设备驱动来实现
5. 代码量大，复杂。不从零开始写代码，而是分析代码，移植代码

### 输入子系统
#### 1. 输入子系统的作用和框架
1. 输入设备：按键/keyboard，鼠标/mouse，触摸屏/touchpanel，游戏杆/joystick都是输入设备，输入设备的共同点：获取到数据，将数据上报给用户
2. 输入子系统：兼容所有的输入设备，有统一的编程驱动方法，提供统一的应用操作接口：/dev/input/......，
open("/dev/input/event0")打开设定好的输入设备，read(fd, buf)：buf指的是统一的数据包,struct input_event
3. 框架：分成三层
|框架分层 |
|:--:|
|应用层|
|input handler层：数据处理，完成fops操作：xxx_open(), xxx_read(), xxx_write()...，将数据交给应用|
|input core层：管理层，将数据转发给处理层|
|input device：设备层，抽象出一个对象，描述输入设备信息。初始化出入设备硬件，获取到数据|
|硬件层：鼠标、键盘、触摸屏|
4. 编程主要实在input device层
<img src="F:\学习笔记\Linux\驱动开发_高级.assets\image-20200401165342267.png" alt="image-20200401165342267" style="zoom:50%;" />

#### 2. 输入设备驱动程序
1. 简单输入设备驱动
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/input.h>

struct input_dev *idev;

static int __init simple_input_init(void){
    /*
    1. 分配一个input device对象 struct input_dev *input_allocate_device(void);
    2. 初始化input device对象
    3. 注册input device对象 int input_register_device(struct input_dev *dev )
    */
    idev = input_allocate_device();
    if(idev == NULL){
        printk("error\n");
        return -ENOMEM;
	}
    
    //当前设备能够产生按键数据
    __set_bit(EV_KEY, idev->evbit);
    //按键能够产生power按键
    __set_bit(KEY_POWER, idev->keybit);
    
    input_register_device(idev);
    return 0;   
}

static void __exit simple_input_exit(void){
    input_unregister_device(idev);
    input_free_device(idev);
}

module_inti(simple_input_init);
module_exit(simple_input_exit);
MODULE_LICENSE("GPL");
```
注册成功前提：input core层和input handler层在内核中存在。drivers/input/evdev.c (event handler) drivers/input/input.c (input core)。在make menuconfig ——》input device support 配置

2. 驱动硬件
```c
//修改简单驱动文件
#include <linux/init.h>
#include <linux/module.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/of.h>
#include <linux/of_irq.h>
#inlcude <asm/io.h>

struct input_dev *idev;
void *reg_base;

irqreturn_t input_key_irq_handler(int irqno, void *devid){
    //上报数据:void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);
    //参数1：当前input device上报数据
    //参数2：上报的是哪种数据类型，如：EV_KEY
    //参数3：上报的具体数据是什么，如：kEY_POWER
    //参数4：值是什么
    int value = readl(reg_base + 4) & (1<<2);
    if(value){
        input_event(idev, EV_KEY, KEY_POWER, 1);
        input_sync(idev); //上报数据结束
	}
    return IRQ_HANDLED;
}

static int __init simple_input_init(void){
    /*
    1. 分配一个input device对象 struct input_dev *input_allocate_device(void);
    2. 初始化input device对象
    3. 注册input device对象 int input_register_device(struct input_dev *dev )
    */
    idev = input_allocate_device();
    if(idev == NULL){
        printk("error\n");
        return -ENOMEM;
	}
    
    //当前设备能够产生按键数据
    __set_bit(EV_KEY, idev->evbit);
    //按键能够产生power按键
    __set_bit(KEY_POWER, idev->keybit);
    
    //驱动硬件
    struct device_node *np = of_find_node_by_path("/key");
    int irqno = irq_of_parse_and_map(np, 0);
    request_irq(irqno, input_key_irq_handler, IRQF_TRIGGER_FALLING, "key_exint", NULL);
    
    //映射寄存器地址
    reg_base = ioremap(0x114C0000, 8);
    
    input_register_device(idev);
    return 0;   
}

static void __exit simple_input_exit(void){
    iounmap(regbase);
    free_irq(irqno, NULL);
    input_unregister_device(idev);
    input_free_device(idev);
}
```
```c
//应用程序
/*
struct input_event{
    struct timeval time; //时间戳
    __u16 type; //数据类型
    __u16 code; //具体数据
    __s32 value; //数据数值
}
*/
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main(void){
    int fd;
    int ret;
    struct input_event event;
    
    fd = open("/dev/event1", O_RDWR);
    if(fd < 0){
        perror("open");
        return -1;
    }
    
    while(1){
        ret = read(fd, &event, sizeof(struct input_event));
        if(ret < 0){
            perror("read");
            return -1;
        }
        if(event.type == EV_KEY){
            if(event.code == KEY_POWER){
				if(event.value){
                    printf("power key pressed.\n");
                }
            }
        }
    }
}
```
3. 输入设备
```c
struct input_id{
    __u16 bustype; //总线类型，如：BUS_HOST
    __u16 vendor;
    __u16 product;
    __u16 version;
    
}

struct input_dev{
    const char *name; //sysfs中给用户看的信息
    const char *phys;
    const char *uniq;
    struct input_id id;
    
    //evbit实际是一个位表，描述输入设备能够产生什么类型数据
    unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
    /*
    #define EV_SYN 0x00 //表示同步数据
    #define EV_KEY 0x01 //表示按键数据
    #define EV_REL 0x02 //表示相对坐标数据
    #define EV_ABS 0x03 //表示绝对坐标数据
    #define EV_MSC 0x04 //表示杂项
    #define EV_SW  0x05 //表示开关
    #define EV_LED 0x11 //表示LED数据
    ......
    */
    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
    unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
    unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
    unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
    unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
    
    struct device dev; //继承device对象
    struct list_head h_list;
    struct list_head node;
    
    void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);
    //可以将上述的函数使用input_report_xx()函数代替，其中xx可以是key, rel, abs等event类型名称
    static inline void input_report_key(struct input_dev *dev, unsigned int code, int value); //函数内部调用了input_event(dev, EV_KEY, code, !!value); 两个取反，确保上报的按键一定是0或者1
    
}
```
不同的输入设备能产生不同的数据：
> + 按键/keyboard：产生键值，实际是一个数字
> + 触摸屏：产生坐标（绝对坐标）
> + 鼠标：产生相对坐标

4. 多个按键驱动
```c
//在设备树描述中添加按键相关信息
key_int_node{
    compatible = "test_key";
    #address-cells = <1>;
    #size-cells = <1>;
    
    key_int@0{
        key_name = "key2_power_eint";
        key_code = <116>;
        gpio = <&gpx1 1 0>;
        reg = <0x11000C20 0x18>;
        interrupt-parent = <&gpx1>;
        interrupts = <1 0>;
    };
    
    key_int@1{
        key_name = "key3_vup_eint";
        key_code = <115>;
        gpio = <&gpx1 2 0>;
        reg = <0x11000C20 0x18>;
        interrupt-parent = <&gpx1>;
        interrupts = <2 0>;
    };
};

//驱动程序获取按键信息
struct device_node *of_get_next_child(struct device_node *parent, struct device_node *prev);
//获取中断号
int irqno = irq_of_parse_and_map(struct device_node *device, int index);
//获取key name
of_property_read_string(struct device_node *device, char *label, value);
//获取key code
of_property_read_u32(struct device_node *device, char *label, value);
//获取gpio
of_get_named_gpio(struct device_node *device, int index);
```


### I2C驱动


### 设备树

